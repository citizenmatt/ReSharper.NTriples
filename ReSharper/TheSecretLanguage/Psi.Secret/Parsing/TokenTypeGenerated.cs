//------------------------------------------------------------------------------
// <auto-generated>
//     Generated by TokenGenerator
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
using JetBrains.ReSharper.Psi.ExtensionsAPI.Tree;
using JetBrains.Text;
using JetBrains.ReSharper.Psi.Parsing;

namespace JetBrains.ReSharper.Psi.Secret.Parsing
{
    public static partial class SecretTokenType
    {
        #region URI_BEGIN
        private class UriBeginNodeType : FixedTokenNodeType
        {
            public UriBeginNodeType(): base ("URI_BEGIN", "<") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new UriBeginTokenElement(this);
            }
        }
        private class UriBeginTokenElement : FixedTokenElement
        {
            public UriBeginTokenElement(UriBeginNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType URI_BEGIN = new UriBeginNodeType();
        #endregion

        #region URI_STRING
        private class UriStringNodeType : FixedTokenNodeType
        {
            public UriStringNodeType(): base ("URI_STRING", "http://uri.string/path#localName") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new UriStringTokenElement(this);
            }
        }
        private class UriStringTokenElement : FixedTokenElement
        {
            public UriStringTokenElement(UriStringNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType URI_STRING = new UriStringNodeType();
        #endregion

        #region URI_END
        private class UriEndNodeType : FixedTokenNodeType
        {
            public UriEndNodeType(): base ("URI_END", ">") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new UriEndTokenElement(this);
            }
        }
        private class UriEndTokenElement : FixedTokenElement
        {
            public UriEndTokenElement(UriEndNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType URI_END = new UriEndNodeType();
        #endregion

        #region INTEGER_LITERAL
        private class IntegerLiteralNodeType : FixedTokenNodeType
        {
            public IntegerLiteralNodeType(): base ("INTEGER_LITERAL", "Integer") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new IntegerLiteralTokenElement(this);
            }
        }
        private class IntegerLiteralTokenElement : FixedTokenElement
        {
            public IntegerLiteralTokenElement(IntegerLiteralNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType INTEGER_LITERAL = new IntegerLiteralNodeType();
        #endregion

        #region DOUBLE_LITERAL
        private class DoubleLiteralNodeType : FixedTokenNodeType
        {
            public DoubleLiteralNodeType(): base ("DOUBLE_LITERAL", "Double") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new DoubleLiteralTokenElement(this);
            }
        }
        private class DoubleLiteralTokenElement : FixedTokenElement
        {
            public DoubleLiteralTokenElement(DoubleLiteralNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType DOUBLE_LITERAL = new DoubleLiteralNodeType();
        #endregion

        #region DOT
        private class DotNodeType : FixedTokenNodeType
        {
            public DotNodeType(): base ("DOT", ".") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new DotTokenElement(this);
            }
        }
        private class DotTokenElement : FixedTokenElement
        {
            public DotTokenElement(DotNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType DOT = new DotNodeType();
        #endregion

        #region SEMICOLON
        private class SemicolonNodeType : FixedTokenNodeType
        {
            public SemicolonNodeType(): base ("SEMICOLON", ";") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new SemicolonTokenElement(this);
            }
        }
        private class SemicolonTokenElement : FixedTokenElement
        {
            public SemicolonTokenElement(SemicolonNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType SEMICOLON = new SemicolonNodeType();
        #endregion

        #region COMMA
        private class CommaNodeType : FixedTokenNodeType
        {
            public CommaNodeType(): base ("COMMA", ",") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new CommaTokenElement(this);
            }
        }
        private class CommaTokenElement : FixedTokenElement
        {
            public CommaTokenElement(CommaNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType COMMA = new CommaNodeType();
        #endregion

        #region LANG
        private class LangNodeType : FixedTokenNodeType
        {
            public LangNodeType(): base ("LANG", "@lang") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new LangTokenElement(this);
            }
        }
        private class LangTokenElement : FixedTokenElement
        {
            public LangTokenElement(LangNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType LANG = new LangNodeType();
        #endregion

        #region NAMESPACE_SEPARATOR
        private class NamespaceSeparatorNodeType : FixedTokenNodeType
        {
            public NamespaceSeparatorNodeType(): base ("NAMESPACE_SEPARATOR", ":") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new NamespaceSeparatorTokenElement(this);
            }
        }
        private class NamespaceSeparatorTokenElement : FixedTokenElement
        {
            public NamespaceSeparatorTokenElement(NamespaceSeparatorNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType NAMESPACE_SEPARATOR = new NamespaceSeparatorNodeType();
        #endregion

        #region VARIABLE_PREFIX
        private class VariablePrefixNodeType : FixedTokenNodeType
        {
            public VariablePrefixNodeType(): base ("VARIABLE_PREFIX", "?") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new VariablePrefixTokenElement(this);
            }
        }
        private class VariablePrefixTokenElement : FixedTokenElement
        {
            public VariablePrefixTokenElement(VariablePrefixNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType VARIABLE_PREFIX = new VariablePrefixNodeType();
        #endregion

        #region L_BRACE
        private class LBraceNodeType : FixedTokenNodeType
        {
            public LBraceNodeType(): base ("L_BRACE", "{") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new LBraceTokenElement(this);
            }
        }
        private class LBraceTokenElement : FixedTokenElement
        {
            public LBraceTokenElement(LBraceNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType L_BRACE = new LBraceNodeType();
        #endregion

        #region R_BRACE
        private class RBraceNodeType : FixedTokenNodeType
        {
            public RBraceNodeType(): base ("R_BRACE", "}") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new RBraceTokenElement(this);
            }
        }
        private class RBraceTokenElement : FixedTokenElement
        {
            public RBraceTokenElement(RBraceNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType R_BRACE = new RBraceNodeType();
        #endregion

        #region L_PARENTHESES
        private class LParenthesesNodeType : FixedTokenNodeType
        {
            public LParenthesesNodeType(): base ("L_PARENTHESES", "(") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new LParenthesesTokenElement(this);
            }
        }
        private class LParenthesesTokenElement : FixedTokenElement
        {
            public LParenthesesTokenElement(LParenthesesNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType L_PARENTHESES = new LParenthesesNodeType();
        #endregion

        #region R_PARENTHESES
        private class RParenthesesNodeType : FixedTokenNodeType
        {
            public RParenthesesNodeType(): base ("R_PARENTHESES", ")") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new RParenthesesTokenElement(this);
            }
        }
        private class RParenthesesTokenElement : FixedTokenElement
        {
            public RParenthesesTokenElement(RParenthesesNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType R_PARENTHESES = new RParenthesesNodeType();
        #endregion

        #region L_BRACKET
        private class LBracketNodeType : FixedTokenNodeType
        {
            public LBracketNodeType(): base ("L_BRACKET", "[") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new LBracketTokenElement(this);
            }
        }
        private class LBracketTokenElement : FixedTokenElement
        {
            public LBracketTokenElement(LBracketNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType L_BRACKET = new LBracketNodeType();
        #endregion

        #region R_BRACKET
        private class RBracketNodeType : FixedTokenNodeType
        {
            public RBracketNodeType(): base ("R_BRACKET", "]") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new RBracketTokenElement(this);
            }
        }
        private class RBracketTokenElement : FixedTokenElement
        {
            public RBracketTokenElement(RBracketNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType R_BRACKET = new RBracketNodeType();
        #endregion

        #region NULL_KEYWORD
        private class NullKeywordNodeType : KeywordTokenNodeType
        {
            public NullKeywordNodeType(): base ("NULL_KEYWORD", "null") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new NullKeywordTokenElement(this);
            }
        }
        private class NullKeywordTokenElement : FixedTokenElement
        {
            public NullKeywordTokenElement(NullKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType NULL_KEYWORD = new NullKeywordNodeType();
        #endregion

        #region TRUE_KEYWORD
        private class TrueKeywordNodeType : KeywordTokenNodeType
        {
            public TrueKeywordNodeType(): base ("TRUE_KEYWORD", "true") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new TrueKeywordTokenElement(this);
            }
        }
        private class TrueKeywordTokenElement : FixedTokenElement
        {
            public TrueKeywordTokenElement(TrueKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType TRUE_KEYWORD = new TrueKeywordNodeType();
        #endregion

        #region FALSE_KEYWORD
        private class FalseKeywordNodeType : KeywordTokenNodeType
        {
            public FalseKeywordNodeType(): base ("FALSE_KEYWORD", "false") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new FalseKeywordTokenElement(this);
            }
        }
        private class FalseKeywordTokenElement : FixedTokenElement
        {
            public FalseKeywordTokenElement(FalseKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType FALSE_KEYWORD = new FalseKeywordNodeType();
        #endregion

        #region HAS_KEYWORD
        private class HasKeywordNodeType : KeywordTokenNodeType
        {
            public HasKeywordNodeType(): base ("HAS_KEYWORD", "@has") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new HasKeywordTokenElement(this);
            }
        }
        private class HasKeywordTokenElement : FixedTokenElement
        {
            public HasKeywordTokenElement(HasKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType HAS_KEYWORD = new HasKeywordNodeType();
        #endregion

        #region IS_KEYWORD
        private class IsKeywordNodeType : KeywordTokenNodeType
        {
            public IsKeywordNodeType(): base ("IS_KEYWORD", "@is") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new IsKeywordTokenElement(this);
            }
        }
        private class IsKeywordTokenElement : FixedTokenElement
        {
            public IsKeywordTokenElement(IsKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType IS_KEYWORD = new IsKeywordNodeType();
        #endregion

        #region FOR_ALL_KEYWORD
        private class ForAllKeywordNodeType : KeywordTokenNodeType
        {
            public ForAllKeywordNodeType(): base ("FOR_ALL_KEYWORD", "@forAll") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new ForAllKeywordTokenElement(this);
            }
        }
        private class ForAllKeywordTokenElement : FixedTokenElement
        {
            public ForAllKeywordTokenElement(ForAllKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType FOR_ALL_KEYWORD = new ForAllKeywordNodeType();
        #endregion

        #region FOR_SOME_KEYWORD
        private class ForSomeKeywordNodeType : KeywordTokenNodeType
        {
            public ForSomeKeywordNodeType(): base ("FOR_SOME_KEYWORD", "@forSome") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new ForSomeKeywordTokenElement(this);
            }
        }
        private class ForSomeKeywordTokenElement : FixedTokenElement
        {
            public ForSomeKeywordTokenElement(ForSomeKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType FOR_SOME_KEYWORD = new ForSomeKeywordNodeType();
        #endregion

        #region A_KEYWORD
        private class AKeywordNodeType : KeywordTokenNodeType
        {
            public AKeywordNodeType(): base ("A_KEYWORD", "a") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new AKeywordTokenElement(this);
            }
        }
        private class AKeywordTokenElement : FixedTokenElement
        {
            public AKeywordTokenElement(AKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType A_KEYWORD = new AKeywordNodeType();
        #endregion

        #region OF_KEYWORD
        private class OfKeywordNodeType : KeywordTokenNodeType
        {
            public OfKeywordNodeType(): base ("OF_KEYWORD", "@of") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new OfKeywordTokenElement(this);
            }
        }
        private class OfKeywordTokenElement : FixedTokenElement
        {
            public OfKeywordTokenElement(OfKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType OF_KEYWORD = new OfKeywordNodeType();
        #endregion

        #region PREFIX_KEYWORD
        private class PrefixKeywordNodeType : KeywordTokenNodeType
        {
            public PrefixKeywordNodeType(): base ("PREFIX_KEYWORD", "@prefix") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new PrefixKeywordTokenElement(this);
            }
        }
        private class PrefixKeywordTokenElement : FixedTokenElement
        {
            public PrefixKeywordTokenElement(PrefixKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType PREFIX_KEYWORD = new PrefixKeywordNodeType();
        #endregion

        #region STD_PREFIX_KEYWORD
        private class StdPrefixKeywordNodeType : KeywordTokenNodeType
        {
            public StdPrefixKeywordNodeType(): base ("STD_PREFIX_KEYWORD", "@std_prefix") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new StdPrefixKeywordTokenElement(this);
            }
        }
        private class StdPrefixKeywordTokenElement : FixedTokenElement
        {
            public StdPrefixKeywordTokenElement(StdPrefixKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType STD_PREFIX_KEYWORD = new StdPrefixKeywordNodeType();
        #endregion

        #region EXTENSION_KEYWORD
        private class ExtensionKeywordNodeType : KeywordTokenNodeType
        {
            public ExtensionKeywordNodeType(): base ("EXTENSION_KEYWORD", "@extension") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new ExtensionKeywordTokenElement(this);
            }
        }
        private class ExtensionKeywordTokenElement : FixedTokenElement
        {
            public ExtensionKeywordTokenElement(ExtensionKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType EXTENSION_KEYWORD = new ExtensionKeywordNodeType();
        #endregion

        #region USING_KEYWORD
        private class UsingKeywordNodeType : KeywordTokenNodeType
        {
            public UsingKeywordNodeType(): base ("USING_KEYWORD", "@using") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new UsingKeywordTokenElement(this);
            }
        }
        private class UsingKeywordTokenElement : FixedTokenElement
        {
            public UsingKeywordTokenElement(UsingKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType USING_KEYWORD = new UsingKeywordNodeType();
        #endregion

        #region DEFAULT_AXIS_KEYWORD
        private class DefaultAxisKeywordNodeType : KeywordTokenNodeType
        {
            public DefaultAxisKeywordNodeType(): base ("DEFAULT_AXIS_KEYWORD", "@axis-default") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new DefaultAxisKeywordTokenElement(this);
            }
        }
        private class DefaultAxisKeywordTokenElement : FixedTokenElement
        {
            public DefaultAxisKeywordTokenElement(DefaultAxisKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType DEFAULT_AXIS_KEYWORD = new DefaultAxisKeywordNodeType();
        #endregion

        #region AXIS_KEYWORD
        private class AxisKeywordNodeType : KeywordTokenNodeType
        {
            public AxisKeywordNodeType(): base ("AXIS_KEYWORD", "@?axis") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new AxisKeywordTokenElement(this);
            }
        }
        private class AxisKeywordTokenElement : FixedTokenElement
        {
            public AxisKeywordTokenElement(AxisKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType AXIS_KEYWORD = new AxisKeywordNodeType();
        #endregion

        #region FUNCTOR_KEYWORD
        private class FunctorKeywordNodeType : KeywordTokenNodeType
        {
            public FunctorKeywordNodeType(): base ("FUNCTOR_KEYWORD", "@?functor") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new FunctorKeywordTokenElement(this);
            }
        }
        private class FunctorKeywordTokenElement : FixedTokenElement
        {
            public FunctorKeywordTokenElement(FunctorKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType FUNCTOR_KEYWORD = new FunctorKeywordNodeType();
        #endregion

        #region META_KEYWORD
        private class MetaKeywordNodeType : KeywordTokenNodeType
        {
            public MetaKeywordNodeType(): base ("META_KEYWORD", "@?meta") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new MetaKeywordTokenElement(this);
            }
        }
        private class MetaKeywordTokenElement : FixedTokenElement
        {
            public MetaKeywordTokenElement(MetaKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType META_KEYWORD = new MetaKeywordNodeType();
        #endregion

        #region IN_KEYWORD
        private class InKeywordNodeType : KeywordTokenNodeType
        {
            public InKeywordNodeType(): base ("IN_KEYWORD", "@?in|@for") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new InKeywordTokenElement(this);
            }
        }
        private class InKeywordTokenElement : FixedTokenElement
        {
            public InKeywordTokenElement(InKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType IN_KEYWORD = new InKeywordNodeType();
        #endregion

        #region OUT_KEYWORD
        private class OutKeywordNodeType : KeywordTokenNodeType
        {
            public OutKeywordNodeType(): base ("OUT_KEYWORD", "@?out") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new OutKeywordTokenElement(this);
            }
        }
        private class OutKeywordTokenElement : FixedTokenElement
        {
            public OutKeywordTokenElement(OutKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType OUT_KEYWORD = new OutKeywordNodeType();
        #endregion

        #region SELECT_KEYWORD
        private class SelectKeywordNodeType : KeywordTokenNodeType
        {
            public SelectKeywordNodeType(): base ("SELECT_KEYWORD", "@?select") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new SelectKeywordTokenElement(this);
            }
        }
        private class SelectKeywordTokenElement : FixedTokenElement
        {
            public SelectKeywordTokenElement(SelectKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType SELECT_KEYWORD = new SelectKeywordNodeType();
        #endregion

        #region FROM_KEYWORD
        private class FromKeywordNodeType : KeywordTokenNodeType
        {
            public FromKeywordNodeType(): base ("FROM_KEYWORD", "@?from") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new FromKeywordTokenElement(this);
            }
        }
        private class FromKeywordTokenElement : FixedTokenElement
        {
            public FromKeywordTokenElement(FromKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType FROM_KEYWORD = new FromKeywordNodeType();
        #endregion

        #region NOT_KEYWORD
        private class NotKeywordNodeType : KeywordTokenNodeType
        {
            public NotKeywordNodeType(): base ("NOT_KEYWORD", "@?not") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new NotKeywordTokenElement(this);
            }
        }
        private class NotKeywordTokenElement : FixedTokenElement
        {
            public NotKeywordTokenElement(NotKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType NOT_KEYWORD = new NotKeywordNodeType();
        #endregion

        #region IF_KEYWORD
        private class IfKeywordNodeType : KeywordTokenNodeType
        {
            public IfKeywordNodeType(): base ("IF_KEYWORD", "@?if") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new IfKeywordTokenElement(this);
            }
        }
        private class IfKeywordTokenElement : FixedTokenElement
        {
            public IfKeywordTokenElement(IfKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType IF_KEYWORD = new IfKeywordNodeType();
        #endregion

        #region TRY_KEYWORD
        private class TryKeywordNodeType : KeywordTokenNodeType
        {
            public TryKeywordNodeType(): base ("TRY_KEYWORD", "@?try") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new TryKeywordTokenElement(this);
            }
        }
        private class TryKeywordTokenElement : FixedTokenElement
        {
            public TryKeywordTokenElement(TryKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType TRY_KEYWORD = new TryKeywordNodeType();
        #endregion

        #region OR_KEYWORD
        private class OrKeywordNodeType : KeywordTokenNodeType
        {
            public OrKeywordNodeType(): base ("OR_KEYWORD", "@?or") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new OrKeywordTokenElement(this);
            }
        }
        private class OrKeywordTokenElement : FixedTokenElement
        {
            public OrKeywordTokenElement(OrKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType OR_KEYWORD = new OrKeywordNodeType();
        #endregion

        #region IF_NOT_KEYWORD
        private class IfNotKeywordNodeType : KeywordTokenNodeType
        {
            public IfNotKeywordNodeType(): base ("IF_NOT_KEYWORD", "@?if-not") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new IfNotKeywordTokenElement(this);
            }
        }
        private class IfNotKeywordTokenElement : FixedTokenElement
        {
            public IfNotKeywordTokenElement(IfNotKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType IF_NOT_KEYWORD = new IfNotKeywordNodeType();
        #endregion

        #region THEN_KEYWORD
        private class ThenKeywordNodeType : KeywordTokenNodeType
        {
            public ThenKeywordNodeType(): base ("THEN_KEYWORD", "@?then") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new ThenKeywordTokenElement(this);
            }
        }
        private class ThenKeywordTokenElement : FixedTokenElement
        {
            public ThenKeywordTokenElement(ThenKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType THEN_KEYWORD = new ThenKeywordNodeType();
        #endregion

        #region ELSE_KEYWORD
        private class ElseKeywordNodeType : KeywordTokenNodeType
        {
            public ElseKeywordNodeType(): base ("ELSE_KEYWORD", "@?else") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new ElseKeywordTokenElement(this);
            }
        }
        private class ElseKeywordTokenElement : FixedTokenElement
        {
            public ElseKeywordTokenElement(ElseKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType ELSE_KEYWORD = new ElseKeywordNodeType();
        #endregion

        #region ONCE_KEYWORD
        private class OnceKeywordNodeType : KeywordTokenNodeType
        {
            public OnceKeywordNodeType(): base ("ONCE_KEYWORD", "@?once") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new OnceKeywordTokenElement(this);
            }
        }
        private class OnceKeywordTokenElement : FixedTokenElement
        {
            public OnceKeywordTokenElement(OnceKeywordNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType ONCE_KEYWORD = new OnceKeywordNodeType();
        #endregion

        #region BIND
        private class BindNodeType : FixedTokenNodeType
        {
            public BindNodeType(): base ("BIND", "->") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new BindTokenElement(this);
            }
        }
        private class BindTokenElement : FixedTokenElement
        {
            public BindTokenElement(BindNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType BIND = new BindNodeType();
        #endregion

        #region IMPLIES
        private class ImpliesNodeType : FixedTokenNodeType
        {
            public ImpliesNodeType(): base ("IMPLIES", "=>") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new ImpliesTokenElement(this);
            }
        }
        private class ImpliesTokenElement : FixedTokenElement
        {
            public ImpliesTokenElement(ImpliesNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType IMPLIES = new ImpliesNodeType();
        #endregion

        #region SAME_AS
        private class SameAsNodeType : FixedTokenNodeType
        {
            public SameAsNodeType(): base ("SAME_AS", "=") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new SameAsTokenElement(this);
            }
        }
        private class SameAsTokenElement : FixedTokenElement
        {
            public SameAsTokenElement(SameAsNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType SAME_AS = new SameAsNodeType();
        #endregion

        #region NAME_KEY
        private class NameKeyNodeType : FixedTokenNodeType
        {
            public NameKeyNodeType(): base ("NAME_KEY", ":-") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new NameKeyTokenElement(this);
            }
        }
        private class NameKeyTokenElement : FixedTokenElement
        {
            public NameKeyTokenElement(NameKeyNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType NAME_KEY = new NameKeyNodeType();
        #endregion

        #region EQUAL_TO
        private class EqualToNodeType : FixedTokenNodeType
        {
            public EqualToNodeType(): base ("EQUAL_TO", ":=|==") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new EqualToTokenElement(this);
            }
        }
        private class EqualToTokenElement : FixedTokenElement
        {
            public EqualToTokenElement(EqualToNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType EQUAL_TO = new EqualToNodeType();
        #endregion

        #region NOT_EQUAL_TO
        private class NotEqualToNodeType : FixedTokenNodeType
        {
            public NotEqualToNodeType(): base ("NOT_EQUAL_TO", "!=") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new NotEqualToTokenElement(this);
            }
        }
        private class NotEqualToTokenElement : FixedTokenElement
        {
            public NotEqualToTokenElement(NotEqualToNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType NOT_EQUAL_TO = new NotEqualToNodeType();
        #endregion

        #region CONNECT
        private class ConnectNodeType : FixedTokenNodeType
        {
            public ConnectNodeType(): base ("CONNECT", "<->") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new ConnectTokenElement(this);
            }
        }
        private class ConnectTokenElement : FixedTokenElement
        {
            public ConnectTokenElement(ConnectNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType CONNECT = new ConnectNodeType();
        #endregion

        #region ELLIPSIS
        private class EllipsisNodeType : FixedTokenNodeType
        {
            public EllipsisNodeType(): base ("ELLIPSIS", "...") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new EllipsisTokenElement(this);
            }
        }
        private class EllipsisTokenElement : FixedTokenElement
        {
            public EllipsisTokenElement(EllipsisNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType ELLIPSIS = new EllipsisNodeType();
        #endregion

        #region DATA_SUFFIX
        private class DataSuffixNodeType : FixedTokenNodeType
        {
            public DataSuffixNodeType(): base ("DATA_SUFFIX", "^^") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new DataSuffixTokenElement(this);
            }
        }
        private class DataSuffixTokenElement : FixedTokenElement
        {
            public DataSuffixTokenElement(DataSuffixNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType DATA_SUFFIX = new DataSuffixNodeType();
        #endregion

        #region EXPRESSION_TAIL_OPERATOR
        private class ExpressionTailOperatorNodeType : FixedTokenNodeType
        {
            public ExpressionTailOperatorNodeType(): base ("EXPRESSION_TAIL_OPERATOR", "^") {}
            public override LeafElementBase Create(IBuffer buffer, TreeOffset startOffset, TreeOffset endOffset)
            {
                return new ExpressionTailOperatorTokenElement(this);
            }
        }
        private class ExpressionTailOperatorTokenElement : FixedTokenElement
        {
            public ExpressionTailOperatorTokenElement(ExpressionTailOperatorNodeType tokenNodeType) : base(tokenNodeType) { }
        }
        public static readonly TokenNodeType EXPRESSION_TAIL_OPERATOR = new ExpressionTailOperatorNodeType();
        #endregion

    }
}
 
