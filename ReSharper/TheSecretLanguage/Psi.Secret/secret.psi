options {
    parserPackage="JetBrains.ReSharper.Psi.Secret.Parsing";
    parserClassName="SecretParserGenerated";
    psiInterfacePackageName="JetBrains.ReSharper.Psi.Secret.Tree";
    psiStubsPackageName="JetBrains.ReSharper.Psi.Secret.Impl.Tree";
    psiStubsBaseClass="SecretCompositeElement";
    tokenTypePrefix="";
    parserTargetSubdir="Parsing/Secret";
    psiInterfacesTargetSubdir="Psi/Secret/Tree";
    psiStubsTargetSubdir="Psi/Secret/Tree/Impl";
    elementTypePrefix="";
    visitorClassName="TreeNodeVisitor";
    visitorMethodSuffix="";
    testTargetSubdir="Psi/Test/Secret";
    disableReflection;
    separateHierarchies;
    "treeElementClassFQName"="JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement";
    "compositeElementClassFQName"="SecretCompositeElement";
    "psiElementVisitorClassFQName"="JetBrains.ReSharper.Psi.Secret.Tree.TreeNodeVisitor";
    "tokenTypeClassFQName"="JetBrains.ReSharper.Psi.Secret.Parsing.SecretTokenType";
    "visitMethodPrefix"="Visit";
    "lexerClassName"="JetBrains.ReSharper.Psi.Parsing.ILexer<int>";
    "psiClassesPrefix"="";
    "psiElementClassFQName"="JetBrains.ReSharper.Psi.Secret.Tree.ISecretTreeNode";
    customImplPackage="JetBrains.ReSharper.Psi.Secret.Impl.Tree";
    customInterfacePackage="JetBrains.ReSharper.Psi.Secret.Tree";
    "interfaceNamePrefix"="I";
    "tokenElementClassFQName"="JetBrains.ReSharper.Psi.Tree.ITokenNode";
    "customImplSuffix"="";
    "objectClassFQName"="System.Object";
    tokenBitsetThreshold=4;
    elementTypeBaseClass="JetBrains.ReSharper.Psi.Secret.Tree.SecretCompositeNodeType";
    parserMessagesClass="JetBrains.ReSharper.Psi.Secret.Parsing.ParserMessages";
    generateWorkingPsi;
}

errorhandling SecretFile
options
{
  customInterface;
  stubBase = "SecretFileElement";
}
  :
    sentences
  ;

sentences
  :
    sentence? (DOT sentence?)*
  ;

sentence
    :
    statement<STATEMENT, Statement>
    | directive<DIRECTIVE, Directive>
    ;

directive
  :
    prefixDirective
    | stdPrefixDirective
    | extensionDirective
    | useExternalDirective
    | axisDirective
    | forAllDirective
    | forSomeDirective
  ;

prefixDirective
  :
    PREFIX_KEYWORD
    IDENTIFIER
    NAMESPACE_SEPARATOR
    URI_BEGIN
    URI_STRING
    URI_END
  ;

stdPrefixDirective
  :
    STD_PREFIX_KEYWORD
    IDENTIFIER
    NAMESPACE_SEPARATOR
    URI_BEGIN
    URI_STRING
    URI_END
  ;

extensionDirective
  :
    EXTENSION_KEYWORD
    uriIdentifier
    uriIdentifier
  ;

useExternalDirective
  :
    USING_KEYWORD
    URI_BEGIN
    URI_STRING
    URI_END
    (uriIdentifiers)?
  ;

axisDirective
  :
    DEFAULT_AXIS_KEYWORD
    (uriIdentifiers)?
  ;

forAllDirective
  :
    FOR_ALL_KEYWORD
    uriIdentifiers
  ;

forSomeDirective
  :
    FOR_ALL_KEYWORD
    uriIdentifiers
  ;

statement
  :
    (
      subject
      facts
    )
    | keywordStatement
  ;

keywordStatement
  :
    ifStatement
    | notStatement
    | fromStatement
    | orStatement
    | functorStatement
    | cutStatement
  ;

ifStatement
  :
    (
      IF_KEYWORD
      | IF_NOT_KEYWORD
    )
    formula
    THEN_KEYWORD
    formula
    (
      ELSE_KEYWORD
      formula
    )?
  ;

notStatement
  :
    NOT_KEYWORD
    formula
  ;

fromStatement
  :
    FROM_KEYWORD
    formula
    SELECT_KEYWORD
    (
      formula
      | list
      | variableIdentifier
    )
    BIND
    variableIdentifier
  ;

orStatement
  :
    (
      OR_KEYWORD
      | TRY_KEYWORD
    )
    formula
    OR_KEYWORD
    orStatement_
  ;

orStatement_
  :
    formula
    (
      OR_KEYWORD
      orStatement_
    )?
  ;

functorStatement
  :
    FUNCTOR_KEYWORD
    uriIdentifier
    smartVar
    BIND
    smartVar
    formula
  ;

smartVar
  :
    list
    | variableIdentifier
  ;

cutStatement
  :
    ONCE_KEYWORD
    formula
  ;

subject
  :
    identifier
  ;

facts
  :
    (
      NAME_KEY
      identifier
      (
        SEMICOLON
        facts_
      )?
    )
    | facts_
  ;

facts_
  :
    fact
    (
      SEMICOLON
      fact
    )*
  ;

fact
  :
    predicate
    objects
  ;

predicate
  :
    expression
    | SAME_AS
    | IMPLIES
    | A_KEYWORD
    | (HAS_KEYWORD expression)
    | (IS_KEYWORD expression OF_KEYWORD)
    | EQUAL_TO
    | NOT_EQUAL_TO
    | BIND
    | CONNECT
  ;

objects
  :
    identifier
    (
      COMMA
      identifier
    )*
  ;

identifier
  :
    uriIdentifier
    | anonymousIdentifier
    | literal
    | literal_keywords
    | variableIdentifier
    | list
    | formula
  ;

uriIdentifier
  :
    (
      IDENTIFIER
      NAMESPACE_SEPARATOR
      IDENTIFIER
    )
    | (
      URI_BEGIN
      URI_STRING
      URI_END
    )
  ;

formula
  :
    (
      metas
      DOT
    )?
    formula_
  ;

formula_
  :
    L_BRACE
    (
      NAME_KEY
      identifier
    )?
    formulaContent
    R_BRACE
  ;

formulaContent
  :
    sentences
  ;

// inference logic rules meta definitions
metas
  :
    meta
    (
      DOT
      metas
    )?
  ;

meta
  :
    (
      (
        IN_KEYWORD
        variables
      )
      | (
        OUT_KEYWORD
        variables
      )
      | (
        AXIS_KEYWORD
        uriIdentifiers
      )
      | (
        META_KEYWORD
        anonymousIdentifier
      )
    )
  ;

uriIdentifiers
  :
    uriIdentifier
    (
      COMMA
      uriIdentifiers
    )?
  ;

variables
  :
    VARIABLE_PREFIX
    IDENTIFIER
    (
      COMMA
      variables
    )?
  ;

list
  :
    L_PARENTHESES
    (
      expression
      | ELLIPSIS
    )*
    R_PARENTHESES
  ;

expression
  :
    identifier
    (
      EXPRESSION_TAIL_OPERATOR
      expression
    )?
  ;

variableIdentifier
  :
    VARIABLE_PREFIX
    IDENTIFIER?
  ;

literal_keywords
  :
    TRUE_KEYWORD
    | FALSE_KEYWORD
    | NULL_KEYWORD
  ;

literal
  :
    INTEGER_LITERAL
    | DOUBLE_LITERAL
    | dataLiteral
  ;

dataLiteral
  :
    STRING_LITERAL
    (
      LANG
      | DATA_SUFFIX
      uriIdentifier
    )?
  ;

anonymousIdentifier
  :
    (
      L_BRACKET
      facts_?
      SEMICOLON?
      R_BRACKET
    )
    | (
      L_BRACKET
      NAME_KEY
      identifier
      (SEMICOLON facts_)?
      SEMICOLON?
      R_BRACKET
    )
  ;