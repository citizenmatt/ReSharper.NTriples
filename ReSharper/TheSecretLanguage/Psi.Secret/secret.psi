options {
    parserPackage="JetBrains.ReSharper.Psi.Secret.Parsing";
    parserClassName="SecretParserGenerated";
    psiInterfacePackageName="JetBrains.ReSharper.Psi.Secret.Tree";
    psiStubsPackageName="JetBrains.ReSharper.Psi.Secret.Tree.Impl";
    psiStubsBaseClass="SecretCompositeElement";
    tokenTypePrefix="";
    parserTargetSubdir="Parsing/Secret";
    psiInterfacesTargetSubdir="Psi/Secret/Tree";
    psiStubsTargetSubdir="Psi/Secret/Tree/Impl";
    elementTypePrefix="";
    visitorClassName="TreeNodeVisitor";
    visitorMethodSuffix="";
    testTargetSubdir="Psi/Test/Secret";
    disableReflection;
    separateHierarchies;
    "treeElementClassFQName"="JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement";
    "compositeElementClassFQName"="SecretCompositeElement";
    "psiElementVisitorClassFQName"="JetBrains.ReSharper.Psi.Secret.Tree.TreeNodeVisitor";
    "tokenTypeClassFQName"="JetBrains.ReSharper.Psi.Secret.Parsing.SecretTokenType";
    "visitMethodPrefix"="Visit";
    "lexerClassName"="JetBrains.ReSharper.Psi.Parsing.ILexer<int>";
    "psiClassesPrefix"="";
    "psiElementClassFQName"="JetBrains.ReSharper.Psi.Secret.Tree.ISecretTreeNode";
    customImplPackage="JetBrains.ReSharper.Psi.Secret.Tree.Impl";
    customInterfacePackage="JetBrains.ReSharper.Psi.Secret.Tree";
    "interfaceNamePrefix"="I";
    "tokenElementClassFQName"="JetBrains.ReSharper.Psi.Tree.ITokenNode";
    "customImplSuffix"="";
    "objectClassFQName"="System.Object";
    tokenBitsetThreshold=4;
    elementTypeBaseClass="JetBrains.ReSharper.Psi.Secret.Tree.SecretCompositeNodeType";
    parserMessagesClass="JetBrains.ReSharper.Psi.Secret.Parsing.ParserMessages";
    generateWorkingPsi;
}

errorhandling SecretFile
options
{
  customInterface;
  stubBase = "SecretFileElement";
}
/*extras
{
  get { methodName = "Definitions" path = <SecretFile:IMPLEMENTATION_UNIT/implementationUnit:DEFINITION> } ;
  get { methodName = "IdentifierName" path = <FSharpFile:MODULE_NAME/qualifiedIdentifierName:NAME> } ;
}*/
  :
    statement*
  ;

statement
  :
    identifier
    facts
    DOT
  ;

facts
  :
    fact
    (
      SEMICOLON
      fact
    )*
  ;

fact
  :
    predicate
    object
  ;

predicate
  :
    identifier
  ;

object
  :
    identifier
    (
      COMMA
      identifier
    )*
  ;

identifier
  :
    (
      IDENTIFIER
      NAMESPACE_SEPARATOR
      IDENTIFIER
    )
    | (
      URI_BEGIN
      URI_STRING
      URI_END
    )
    | anonymousIdentifier
    | literal
    | literal_keywords
  ;

literal_keywords
  :
    TRUE_KEYWORD
    | FALSE_KEYWORD
    | NULL_KEYWORD
  ;

literal
  :
    STRING_LITERAL
    | INTEGER_LITERAL
    | DOUBLE_LITERAL
  ;

anonymousIdentifier
  :
    L_BRACKET
    facts?
    SEMICOLON?
    R_BRACKET
  ;