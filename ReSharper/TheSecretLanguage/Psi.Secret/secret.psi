options {
    parserPackage="JetBrains.ReSharper.Psi.Secret.Parsing";
    parserClassName="SecretParserGenerated";
    psiInterfacePackageName="JetBrains.ReSharper.Psi.Secret.Tree";
    psiStubsPackageName="JetBrains.ReSharper.Psi.Secret.Impl.Tree";
    psiStubsBaseClass="SecretCompositeElement";
    tokenTypePrefix="";
    parserTargetSubdir="Parsing/Secret";
    psiInterfacesTargetSubdir="Psi/Secret/Tree";
    psiStubsTargetSubdir="Psi/Secret/Tree/Impl";
    elementTypePrefix="";
    visitorClassName="TreeNodeVisitor";
    visitorMethodSuffix="";
    testTargetSubdir="Psi/Test/Secret";
    disableReflection;
    separateHierarchies;
    "treeElementClassFQName"="JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement";
    "compositeElementClassFQName"="SecretCompositeElement";
    "psiElementVisitorClassFQName"="JetBrains.ReSharper.Psi.Secret.Tree.TreeNodeVisitor";
    "tokenTypeClassFQName"="JetBrains.ReSharper.Psi.Secret.Parsing.SecretTokenType";
    "visitMethodPrefix"="Visit";
    "lexerClassName"="JetBrains.ReSharper.Psi.Parsing.ILexer<int>";
    "psiClassesPrefix"="";
    "psiElementClassFQName"="JetBrains.ReSharper.Psi.Secret.Tree.ISecretTreeNode";
    customImplPackage="JetBrains.ReSharper.Psi.Secret.Impl.Tree";
    customInterfacePackage="JetBrains.ReSharper.Psi.Secret.Tree";
    "interfaceNamePrefix"="I";
    "tokenElementClassFQName"="JetBrains.ReSharper.Psi.Tree.ITokenNode";
    "customImplSuffix"="";
    "objectClassFQName"="System.Object";
    tokenBitsetThreshold=4;
    elementTypeBaseClass="JetBrains.ReSharper.Psi.Secret.Tree.SecretCompositeNodeType";
    parserMessagesClass="JetBrains.ReSharper.Psi.Secret.Parsing.ParserMessages";
    generateWorkingPsi;
}

errorhandling SecretFile
options
{
  customInterface;
  stubBase = "SecretFileElement";
}
extras
{
    get {methodName = "Sentences" path = <SecretFile:SENTENCES/sentences:SENTENCES> };
}
  :
    sentences<SENTENCES>
  ;

sentences
  :
    sentence<SENTENCES>? (DOT sentence<SENTENCES>?)*
  ;

errorhandling sentence
    :
    statement<STATEMENT, Statement>
    | directive<DIRECTIVE, Directive>
    ;

errorhandling directive
  :
    prefixDeclaration
    | extensionDirective
    | useExternalDirective
    | axisDirective
    | forAllDirective
    | forSomeDirective
  ;

prefixDeclaration
  :
    (
      PREFIX_KEYWORD<PREFIX, Prefix>
      | STD_PREFIX_KEYWORD<PREFIX, Prefix>
    )
    prefixDeclaredName<IDENTIFIER, PrefixName>
    NAMESPACE_SEPARATOR
    URI_BEGIN
    URI_STRING<URI_STRING, UriString>
    URI_END
  ;

prefixDeclaredName
  :
    IDENTIFIER
  ;

extensionDirective
  :
    EXTENSION_KEYWORD
    uriIdentifier
    uriIdentifier
  ;

useExternalDirective
  :
    USING_KEYWORD
    URI_BEGIN
    URI_STRING
    URI_END
    (uriIdentifiers)?
  ;

axisDirective
  :
    DEFAULT_AXIS_KEYWORD
    (uriIdentifiers)?
  ;

forAllDirective
  :
    FOR_ALL_KEYWORD
    uriIdentifiers
  ;

forSomeDirective
  :
    FOR_SOME_KEYWORD
    uriIdentifiers
  ;

errorhandling statement
  :
    (
      subject<SUBJECT>
      facts<FACTS>
    )
    | keywordStatement
  ;

keywordStatement
  :
    ifStatement
    | notStatement
    | fromStatement
    | orStatement
    | functorStatement
    | cutStatement
  ;

ifStatement
  :
    (
      IF_KEYWORD
      | IF_NOT_KEYWORD
    )
    formula<IF_FORMULA>
    THEN_KEYWORD
    formula<THEN_FORMULA>
    (
      ELSE_KEYWORD
      formula<ELSE_FORMULA>
    )?
  ;

notStatement
  :
    NOT_KEYWORD
    formula<FORMULA>
  ;

fromStatement
  :
    FROM_KEYWORD
    formula<FROM_FORMULA>
    SELECT_KEYWORD
    (
      formula
      | list
      | variableIdentifier
    )
    BIND
    variableIdentifier<BIND_VARIABLE_IDENTIFIER>
  ;

orStatement
  :
    (
      OR_KEYWORD
      | TRY_KEYWORD
    )
    (
      formula<FORMULA>
      OR_KEYWORD
    )*
    formula<FORMULA>
  ;

functorStatement
  :
    FUNCTOR_KEYWORD
    uriIdentifier
    smartVar
    BIND
    smartVar
    formula
  ;

smartVar
  :
    list
    | variableIdentifier
  ;

cutStatement
  :
    ONCE_KEYWORD
    formula
  ;

subject
  :
    identifier
  ;

errorhandling facts
  :
    (
      NAME_KEY
      identifier
      (
        SEMICOLON
        facts_
      )?
    )
    | facts_
  ;

private facts_
  :
    fact<FACTS>
    (
      SEMICOLON
      fact<FACTS>
    )*
  ;

errorhandling fact
  :
    predicate
    objects
  ;

errorhandling predicate
  :
    expression
    | SAME_AS
    | IMPLIES
    | A_KEYWORD
    | hasExpression
    | isOfExpression
    | EQUAL_TO
    | NOT_EQUAL_TO
    | BIND
    | CONNECT
  ;

hasExpression
  :
    HAS_KEYWORD
    expression
  ;

isOfExpression
  :
      IS_KEYWORD
      expression
      OF_KEYWORD
  ;

errorhandling objects
  :
    identifier<IDENTIFIERS>
    (
      COMMA
      identifier<IDENTIFIERS>
    )*
  ;

errorhandling identifier
  :
    uriIdentifier
    | anonymousIdentifier
    | literal
    | literal_keywords
    | variableIdentifier
    | list
    | formula
  ;

uriIdentifier
  :
    (
      prefix<PREFIX, Prefix>
      NAMESPACE_SEPARATOR
      localName<LOCALNAME, LocalName>
    )
    | (
      URI_BEGIN
      URI_STRING<URISTRING, UriString>
      URI_END
    )
  ;

prefix
  :
    IDENTIFIER
  ;

localName
  :
    IDENTIFIER
  ;

errorhandling formula
  :
    (
      metas
    )?
    formula_
  ;

private formula_
  :
    L_BRACE
    (
      NAME_KEY
      identifier<NAME_KEY_IDENTIFIER>
    )?
    formulaContent
    R_BRACE
  ;

private formulaContent
  :
    sentences<SENTENCES>
  ;

// inference logic rules meta definitions
private metas
  :
    (
      meta<META>
      DOT
    )+
  ;

meta
  :
    (
      (
        IN_KEYWORD
        variables
      )
      | (
        OUT_KEYWORD
        variables
      )
      | (
        AXIS_KEYWORD
        uriIdentifiers
      )
      | (
        META_KEYWORD
        anonymousIdentifier
      )
    )
  ;

uriIdentifiers
  :
    uriIdentifier<URI_IDENTIFIERS>
    (
      COMMA
      uriIdentifiers
    )?
  ;

variables
  :
    variableIdentifier<VARIABLE_IDENTIFIER>
    (
      COMMA
      variables
    )?
  ;

errorhandling list
  :
    L_PARENTHESES
    (
      expression<ITEMS>
      | ELLIPSIS
    )*
    R_PARENTHESES
  ;

expression
  :
    identifier<IDENTIFIER>
    (
      EXPRESSION_TAIL_OPERATOR
      identifier<IDENTIFIER>
    )*
  ;

variableIdentifier
  :
    VARIABLE_PREFIX
    IDENTIFIER?
  ;

interface literal_keywords
  :
    TRUE_KEYWORD
    | FALSE_KEYWORD
    | NULL_KEYWORD
  ;

interface literal
  :
    INTEGER_LITERAL
    | DOUBLE_LITERAL
    | dataLiteral
  ;

dataLiteral
  :
    STRING_LITERAL<STRING>
    (
      LANG
      | DATA_SUFFIX
      uriIdentifier
    )?
  ;

anonymousIdentifier
  :
    (
      L_BRACKET
      facts_?
      SEMICOLON?
      R_BRACKET
    )
    | (
      L_BRACKET
      NAME_KEY
      identifier
      (SEMICOLON facts_)?
      SEMICOLON?
      R_BRACKET
    )
  ;