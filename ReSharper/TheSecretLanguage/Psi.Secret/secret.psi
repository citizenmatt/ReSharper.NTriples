options { 
  parserPackage="JetBrains.ReSharper.Psi.Secret.Parsing";
  parserClassName="SecretParserGenerated";
  psiInterfacePackageName="JetBrains.ReSharper.Psi.Secret.Tree";
  psiStubsPackageName="JetBrains.ReSharper.Psi.Secret.Tree.Impl";
  psiStubsBaseClass="SecretCompositeElement";
  tokenTypePrefix="";
  parserTargetSubdir="Parsing/Secret";
  psiInterfacesTargetSubdir="Psi/Secret/Tree";
  psiStubsTargetSubdir="Psi/Secret/Tree/Impl";
  elementTypePrefix="";
  visitorClassName="TreeNodeVisitor";
  visitorMethodSuffix="";
  testTargetSubdir="Psi/Test/FSharp";
  disableReflection;
  separateHierarchies;
  "treeElementClassFQName"="JetBrains.ReSharper.Psi.ExtensionsAPI.Tree.TreeElement";
  "compositeElementClassFQName"="SecretCompositeElement";
  "psiElementVisitorClassFQName"="JetBrains.ReSharper.Psi.FSharp.Tree.TreeNodeVisitor";
  //"tokenClassName"="JetBrains.ReSharper.Psi.FSharp.Impl.Tree.FSharpToken";
  "tokenTypeClassFQName"="JetBrains.ReSharper.Psi.Secret.Parsing.SecretTokenType";
  "visitMethodPrefix"="Visit";
  "lexerClassName"="JetBrains.ReSharper.Psi.Parsing.ILexer<int>";
  "psiClassesPrefix"="";
  "psiElementClassFQName"="JetBrains.ReSharper.Psi.Secret.Tree.ISecretTreeNode";
  customImplPackage="JetBrains.ReSharper.Psi.Secret.Tree.Impl";
  customInterfacePackage="JetBrains.ReSharper.Psi.Secret.Tree";
  "interfaceNamePrefix"="I"; 
  "tokenElementClassFQName"="JetBrains.ReSharper.Psi.Tree.ITokenNode";   
  "customImplSuffix"="";
  "objectClassFQName"="System.Object";
  tokenBitsetThreshold=4;
  elementTypeBaseClass="JetBrains.ReSharper.Psi.Secret.Tree.SecretCompositeNodeType";
  parserMessagesClass="JetBrains.ReSharper.Psi.Secret.Parsing.ParserMessages";
  generateWorkingPsi;
}


private intConstant{ROLE, getter}
 :
    INT_LITERAL<@ROLE, @getter> 
/*  |
    INT8_LITERAL<@ROLE, @getter>
  | 
    UINT8_LITERAL<@ROLE, @getter>
  |
    INT16_LITERAL<@ROLE, @getter>
  |
    UINT16_LITERAL<@ROLE, @getter>
  | 
    INT32_LITERAL<@ROLE, @getter>
  |
    UINT32_LITERAL<@ROLE, @getter>
  |
    NATIVEINT_LITERAL<@ROLE, @getter>
  |
    UNATIVEINT_LITERAL<@ROLE, @getter>
  | 
    INT64_LITERAL<@ROLE, @getter>
  |
    UINT64_LITERAL<@ROLE, @getter> */
;

private floatConstant{ROLE, getter}
 :
     FLOAT_LITERAL<@ROLE, @getter>
/*   |
     FLOAT32_LITERAL<@ROLE, @getter>
   |
     FLOAT64_LITERAL<@ROLE, @getter> */
 ; 

//A.1.1 Naming Objects

// TODO: This was defined as abstract, but there was no implementation
abstract identifier options {
  interfaceName = "JetBrains.ReSharper.Psi.FSharp.Tree.IFSharpIdentifier";
} : IDENTIFIER;

//errorhandling ???
 interface valueName options{ customInterface;}
 :
	identifier
  |
	operatorName
;

operatorName options { customInterface;}
 :
	!(#lparenth: LPAREN)
	operatorNameAux[lparenth]
;

private operatorNameAux[LPAREN lparenth] options{ }
 :
	&lparenth<FSHARP_LPARENTH, LParenth> 
	overloadableOperator{OPERATOR, Operator}
    RPAREN<FSHARP_RPARENTH, RParenth>  	
;

//errorhandling ???
// TODO: This was customParseFunction, but the method wasnt implemented...
qualifiedIdentifierName[qualifiedIdentifierName qualifier] options{customInterface;}
 :
    (	&qualifier<QUALIFIER, Qualifier>	
		RPAREN<FSHARP_DOT, Dot>
	)?
		identifier<NAME, IdentifierName>	
;

private qualifiedIdentifierNameFull{ROLE, getter} options{ }
 :
	!(#id:identifier)
	qualifiedIdentifierName<@ROLE, @getter>[id]
 ;

//errorhandling ???
// TODO: This was customParseFunction, but the method wasnt implemented...
qualifiedValueName options{customInterface;}
 :
    (	qualifiedIdentifierNameFull{QUALIFIER, Qualifier}
		DOT<FSHARP_DOT, Dot>)?		
	valueName<NAME, ValueName>
;

fieldReference options {customInterface;
     stubBase = "ReferenceExpressionBase";}
 :
    (
      moduleReference<QUALIFIER, Qualifier>
      DOT<FSHARP_DOT, Dot>
    )?
    identifier<REFERENCE_NAME, ReferenceName>	
;

//A.1.2 Empty Array and Unit
private emptyList{ROLE, getter}
:
	LBRACK<@ROLE, @getter>
    RBRACK<@ROLE, @getter>
;

private unit{ROLE, getter}
:
	LPAREN<@ROLE, @getter>
    RPAREN<@ROLE, @getter>
;

private emptyArray{ROLE, getter}
:
	LBRACK<@ROLE, @getter>
    RBRACK<@ROLE, @getter>
;

//A.1.3 Constants

private constantValue{ROLE, getter}
 :
	 intConstant{@ROLE, @getter}
  |
     floatConstant{@ROLE, @getter}
  |  
     CHARACTER_LITERAL<@ROLE, @getter>
  |
     STRING_LITERAL<@ROLE, @getter>
  |
     TRUE_KEYWORD<@ROLE, @getter>
  |
     FALSE_KEYWORD<@ROLE, @getter>
  |
     NULL_KEYWORD<@ROLE, @getter>
  |
     emptyList{@ROLE, @getter}
  |
     unit{@ROLE, @getter}
  |
     emptyArray{@ROLE, @getter}
 ;

//A.1.4 Operators
	  
private infixSymbol{ROLE, getter}
 :	
	EQUALS<@ROLE, @getter> 
 | 
	LESS<@ROLE, @getter> 
 |	
	GREATER<@ROLE, @getter> 
 |
	AT<@ROLE, @getter> 
 | 
	BITWISE_XOR<@ROLE, @getter> 
 |
	BAR_BAR<@ROLE, @getter> 
 |
	AMP_AMP<@ROLE, @getter> 
 | 
	PLUS<@ROLE, @getter> 
 |
 	MINUS<@ROLE, @getter> 
 |
	STAR<@ROLE, @getter> 
 | 
	DIV<@ROLE, @getter> 
 |
	PERCENT<@ROLE, @getter> 
;	
	
private prefixSymbol{ROLE, getter}
 :
	EXCLAMATION_OP<@ROLE, @getter> 
 |
	QMARK<@ROLE, @getter> 
 |
	TILDE<@ROLE, @getter> 
;
 
private overloadableOperator{ROLE, getter}
 :
	infixSymbol{@ROLE, @getter}
 |
	prefixSymbol{@ROLE, @getter}
 |
	LESS_GREATER<@ROLE, @getter> 
 |
	PLUS<@ROLE, @getter> 
 |
	MINUS<@ROLE, @getter> 
 |
	MINUS_DOT<@ROLE, @getter> 
 |
	STAR<@ROLE, @getter> 
 |
	EQUALS<@ROLE, @getter> 
 |
	LESS<@ROLE, @getter> 
 |
	GREATER<@ROLE, @getter> 
 |
	AMP<@ROLE, @getter> 
 |
	AMP_AMP<@ROLE, @getter> 
 |
	BAR<@ROLE, @getter> 
 |
	BAR_BAR<@ROLE, @getter> 
 |
	COLON_EQUALS<@ROLE, @getter> 
 |
	PERCENT<@ROLE, @getter> 
 |
	BITWISE_AND<@ROLE, @getter> 
 |
	BITWISE_XOR<@ROLE, @getter> 
 |
	BITWISE_SHIFT_LEFT<@ROLE, @getter> 
 |
	BITWISE_SHIFT_RIGHT<@ROLE, @getter> 
 |
	BITWISE_NOT<@ROLE, @getter> 
;

// A.2 
// A.2.1 The toplevel system

errorhandling FSharpFile
options
{
  customInterface;
  stubBase = "FSharpFileElement";
}
extras
{
  get { methodName = "Definitions" path = <FSharpFile:
IMPLEMENTATION_UNIT/implementationUnit:
DEFINITION> 
}
;
   get { methodName="IdentifierName" path=<FSharpFile
  :
    MODULE_NAME /qualifiedIdentifierName:
NAME> }
  ;
 }
 :
    (
		MODULE_KEYWORD<MODULE_KEYWORD, ModuleKeyword>		
		qualifiedIdentifierNameFull{MODULE_NAME, ModuleName} 
    )?
    implementationUnit<IMPLEMENTATION_UNIT, ImplementationUnit>
 ;
 
 /*
 errorhandling FSharpSpecificationFile
 :
    (
		MODULE_KEYWORD<MODULE_KEYWORD, ModuleKeyword>
		qualifiedIdentifierNameFull{MODULE_NAME, ModuleName}
    )?
    interfaceUnit<SPECIFICATION_UNIT, SpecificationUnit>  
 ;
 */
 
errorhandling interfaceUnit
 :
	(
	  specification<DECLARATION, Declarations>
	  (SEMICOLON_SEMICOLON<FSHARP_SEMICOLONSEMICOLON, SemicolonSemicolon>)?
	)*
;

errorhandling implementationUnit
 :
	(
	  definition<DEFINITION, Definitions>
	  (SEMICOLON_SEMICOLON<FSHARP_SEMICOLONSEMICOLON, SemicolonSemicolon>)?
	)*
;

errorhandling interface specification
 :
	valueSpecification 
 |
	typeDefinition 
 |
	!(#exception: EXCEPTION_KEYWORD)
    !(#ident: identifier)    
	exceptionDefinition[exception, ident]  
 |
	openModuleDefinition  
;

errorhandling interface definition options{ customInterface;}
 :	 
	letDefinition  
 |
	!(#exception: EXCEPTION_KEYWORD)
    !(#ident: identifier)    
	exceptionDefinition[exception, ident]  
 | 
	typeDefinition 
 |
	doExpressionDefinition  
 |
	openModuleDefinition  
 |	
    valueSpecification
;

valueSpecification options { customInterface;
  	stubBase = "JetBrains.ReSharper.Psi.FSharp.Impl.InferenceCacheSupport.InferenceErrorBase";}
 :
	VAL_KEYWORD<VAL_KEYWORD, ValKeyword>
	valueName<VALUE_NAME, ValueName>
	COLON<FSHARP_COLON, Colon>
	typeExpression<TYPE_EXPRESSION, TypeExpression>
;

letDefinition options { customInterface; stubBase = "TypeVariableScopeBase";} 
 : 
   LET_KEYWORD<FSHARP_LET, LetKeyword>
   (REC_KEYWORD<FSHARP_REC, RecKeyword>)?   
   (INLINE_KEYWORD<FSHARP_INLINE, InlineKeyword>)?   
   LIST bindingScheme<BINDING_SCHEME, BindingSchemes> SEP AND_KEYWORD<FSHARP_AND, AndKeyword>  
;

//Warning! Overriding in FSharpParser!!!...
errorhandling attribute
 :
   LBRACK_LESS<FSHARP_LBRACKETLT, LBracetLt>
   attributeReference{ATTRIBUTE_NAME, AttributeName}
   (
	 LPAREN<FSHARP_LPARENT, LParenth>	 
	 tupleExpression<ARGUMENT_LIST, ArgumentList>
	 RPAREN<FSHARP_RPARENTH, RParenth>
   )?      
   GREATER_RBRACK<FSHARP_GTRBRACKET, GtRBracet>
;

//errorhandling ??
attributeReference
 :
    (
      moduleReference<QUALIFIER, Qualifier>
      DOT<FSHARP_DOT, Dot>
    )?
    identifier<REFERENCE_NAME, ReferenceName>	
;

errorhandling interface bindingScheme
:	
	doExpression
   |
	binding 
;

doExpression
 :
	DO_KEYWORD<FSHARP_DO, DoKeyword>	
	expression<EXPRESSION, Expression>
;

errorhandling binding options { customInterface; }
 :
	(attribute<ATTRIBUTE, Attributes>)*	
	bindingSource<SOURCE, Source>  	
	EQUALS<FSHARP_EQ, Eq>
	expression<TARGET, Target>
	
;

//Warning! Overriding in FSharpParser!!!...	
// TODO: This was customParseFunction + noInternalParseFunction, but the methods werent implemented...
errorhandling interface bindingSource options { customInterface;} 
:	
	bindingValueScheme
	|		
	bindingPattern	
;

errorhandling interface bindingValueScheme
 :
	!(#value: valueName)
	bindingValue[value]
	|
	mutableBindingValue
;

bindingPattern options { stubBase = "JetBrains.ReSharper.Psi.FSharp.Impl.InferenceCacheSupport.InferenceErrorBase";}
extras {
  get { methodName="ContainingLetDefinition" path=<binding:
SOURCE/letDefinition:
BINDING_SCHEME> };
}
 :
	pattern<PATTERN, Pattern>
;

//Warning! Overriding in FSharpParser!!!...	
// TODO: This was customParseFunction + noInternalParseFunction, but the methods werent implemented...
bindingValue[valueName value] options {customInterface;
	stubBase = "JetBrains.ReSharper.Psi.FSharp.Impl.InferenceCacheSupport.InferenceErrorBase";}
extras {
  get { methodName="ContainingLetDefinition" path=<binding:
SOURCE/letDefinition:
BINDING_SCHEME> };
}
 :
	&value<NAME, ValueName>
	(pattern<PARAMETER, Parameters>)*
	(
		COLON<FSHARP_COLON, Colon>
		typeExpression<TYPE_EXPRESSION, TypeExpression>
	)?
;
  
mutableBindingValue options {customInterface; stubBase = "JetBrains.ReSharper.Psi.FSharp.Impl.InferenceCacheSupport.InferenceErrorBase";}  
extras {
  get { methodName="ContainingLetDefinition" path=<binding:
SOURCE/letDefinition:
BINDING_SCHEME> };
}
 :
	MUTABLE_KEYWORD<KEYWORD_MUTABLE, MutableKeyword>
	valueName<Name, ValueName>
;
    
interface exceptionDefinition[EXCEPTION_KEYWORD exception, identifier ident] options {customInterface;}
 :
	(!(#of: OF_KEYWORD)
	!(#type: typeExpression))?
	(
	exceptionAlias[exception, ident, of, type]
  |
	exceptionDeclaration[exception, ident, of, type]	
	)
;    
    
exceptionAlias[EXCEPTION_KEYWORD exception, identifier ident, OF_KEYWORD of, typeExpression type]  options {customInterface;
  stubBase = "JetBrains.ReSharper.Psi.FSharp.Impl.InferenceCacheSupport.InferenceTypeBase";}
 :
   &exception<EXCEPTION_KEYWORD, ExceptionKeyword>
   &ident<EXCEPTION_NAME, ExceptionName>	
   (
	  &of<OF_KEYWORD, OFKeyword>
	  &type<TYPE_EXPRESSION, TypeExpression>
   )?
   EQUALS<FSHARP_EQ, Eq>
   exceptionReference<ALIAS, AliasReference>
;

errorhandling exceptionReference options {customInterface;
    stubBase = "ReferenceExpressionBase";}
 :
	(
      moduleReference<QUALIFIER, Qualifier>
      DOT<FSHARP_DOT, Dot>
    )?
    identifier<REFERENCE_NAME, ReferenceName>	
;

exceptionDeclaration[EXCEPTION_KEYWORD exception, identifier ident, OF_KEYWORD of, typeExpression type] options {customInterface;
  stubBase = "JetBrains.ReSharper.Psi.FSharp.Impl.InferenceCacheSupport.InferenceTypeBase";}
 :
   &exception<EXCEPTION_KEYWORD, ExceptionKeyword>
   &ident<EXCEPTION_NAME, ExceptionName>	
   (
	  &of<OF_KEYWORD, OFKeyword>
	  &type<TYPE_EXPRESSION, TypeExpression>
   )?   
;

doExpressionDefinition options {customInterface; stubBase = "TypeVariableScopeBase";}
 :
	DO_KEYWORD<FSHARP_DO, DoKeyword>	
	expression<EXPRESSION, Expression>
;

openModuleDefinition options { customInterface; }
 :
	OPEN_KEYWORD<OPEN_KEYWORD, OpenKeyword>
	moduleReference<USING, Using>
 ;
 
// TODO: This was customParseFunction, but the methods werent implemented...
moduleReference  options{ customInterface;
     stubBase = "ReferenceExpressionBase";}
  :
    (
      moduleReference<QUALIFIER, Qualifier>
      DOT<FSHARP_DOT, Dot>
    )?	    
    identifier<REFERENCE_NAME, ReferenceName>				
 ;
 
 //errorhandling ???
 moduleReferenceList options {customInterface;}
  :
	LIST moduleReferenceOld<REFERENCE_NAME, ReferenceName> SEP DOT<FSHARP_DOT, Dot>
 ;
 
 moduleReferenceOld options{ customInterface;} // customParseFunction;
   :
	 identifier<NAME, Identifier> 
  ;
    

/// A.3 Patterns
 
errorhandling interface pattern options {		
   multilevel: (
	  "As" asValuePattern 	  
 	 ;
 	  "Or" disjunctionPattern				
 	 ;
	  "Tuple" tuplePattern
	 ;	  	  
 	  "List" righta listConstructorPattern			
   );
   customInterface;    
  }
 :
    asValuePattern
  |
    disjunctionPattern
  |
    listConstructorPattern
  |
	tuplePattern
  |
    bracketedPattern
  |
	arrayPattern
  |
	recordPattern
  |
	// !(#lparenth: LPAREN)  //todo:???
	// !(#pattern: pattern)
    parenthesizedPattern				
  |
	//!(#lparenth: LPAREN)   //todo:???
	//!(#pattern: pattern)
	typedPattern							
  |
    underlinePattern				
  |
	parameterizedConstructorPattern		
  |
	//only in structure of parameterizedConstructorPattern
	constructorReference
  |
	valueDeclarationPattern
  |
	constantPattern  
  | 
	rangePattern
  |
	typeTestPattern
;


asValuePattern options {customInterface;  stubBase = "PatternBase";} 
 :
	pattern<PATTERN, Pattern>
	AS_KEYWORD<KEYWORD_AS, AsKeyword>
	valueName<VALUE_NAME, ValueName>
;

disjunctionPattern options {stubBase = "PatternBase";}
 :
	pattern<LEFT_PATTERN, LeftPattern>	
	BAR<FSHARP_OR, Or>
	pattern<RIGHT_PATTERN, RightPattern>	
;
   
listConstructorPattern options {stubBase = "PatternBase";}
 :
	pattern<LEFT_PATTERN, HeadPattern>
	COLON_COLON<FSHARP_COLONCOLON, ColonColon>
	pattern<RIGHT_PATTERN, TailPattern>	
;

tuplePattern options {stubBase = "PatternBase";}
 :
	pattern<PATTERN, Pattern>
	(
	 COMMA<FSHARP_COMMA, Comma>
	 pattern<PATTERN, Pattern>
	)+
;

bracketedPattern options {stubBase = "PatternBase";}
 :
	!(#lbracket: LBRACK)
	brackedPatternAux[lbracket]
 ;

private brackedPatternAux[LBRACK lbracket] options {}
 :
	&lbracket<FSAHRP_LBRACKET, LBracket>	
	LIST pattern<PATTERN, Patterns> SEP SEMICOLON<FSHARP_SEMICOLON, Semicolon>
	RBRACK<FSAHRP_LBRACKET, RBracket>
;

arrayPattern options {stubBase = "PatternBase";}
 :
	!(#lbracketOr: LBRACK_BAR)							
	arrayPatternAux[lbracketOr]
 ;
 
private arrayPatternAux[LBRACK_BAR lbracketOr] options {}
 :
	&lbracketOr<FSAHRP_LBRACKET, LBracket>	
	LIST pattern<PATTERN, Patterns> SEP SEMICOLON<FSHARP_SEMICOLON, Semicolon>
	BAR_RBRACK<FSAHRP_RBRACKET, RBracket>
 ;

recordPattern options {stubBase = "PatternBase";}
 extras {
	get { methodName="FieldPatterns" path=<recordPattern:
FIELD_PATTERNS/fieldPatternList:
FIELD_PATTERN> };
  }
 :
	LBRACE<FSAHRP_LBRACE, LBrace>										
	fieldPatternList<FIELD_PATTERNS, FieldPatternList> 
	RBRACE<FSAHRP_RBRACE, RBrace>
 ;

//Warning! Overriding in FSharpParser!!!...	
fieldPatternList
 :
	LIST fieldPattern<FIELD_PATTERN, FieldPatterns> 
	     SEP SEMICOLON<FSHARP_SEMICOLON, Semicolon>	
;


errorhandling fieldPattern
 :
	fieldReference<FIELD, FieldName>
	EQUALS<FSAHRP_EQ, Eq>
	pattern<PATTERN, Pattern>	
;

parenthesizedPattern options {stubBase = "PatternBase"; } 
 :
	!(#lparenth: LPAREN)
	!(#pattern: pattern)
	parenthesizedPatternAux[lparenth, pattern]
;

private parenthesizedPatternAux[LPAREN lparenth, pattern pattern] options {}
 :
	&lparenth<FSHARP_LPARENTH, LParenth>
	&pattern<PATTERN, Pattern>
	RPAREN<FSHARP_RPARENTH, RParenth>
;
 
typedPattern options {stubBase = "PatternBase";}
 :	
	!(#lparenth: LPAREN)
	!(#pattern: pattern)
	typedPatternAux[lparenth, pattern]
; 

private typedPatternAux[LPAREN lparenth, pattern pattern] options {}
 :
	&lparenth<FSHARP_LPARENTH, LParenth>
	&pattern<PATTERN, Pattern>
	COLON<FSHARP_COLON, Colon>
	typeExpression<TYPE_EXPRESSION, TypeExpression>	
	RPAREN<FSHARP_RPARENTH, RParenth>
;
   
underlinePattern options {stubBase = "PatternBase";}
 :    
	UNDERSCORE<FSHARP_UNDERLINE, Underline>
;

//Constructor without params and qualifiers are here!
valueDeclarationPattern options { 
customInterface;
stubBase = "PatternBase";}
 :
	valueName<VALUE, Value>
;

parameterizedConstructorPattern options {customInterface; stubBase = "PatternBase";}
 :
	constructorReference<CONSTRUCTOR_REFERENCE, ConstructorReference>
	pattern<PARAMETER, Parameter>?
;

constructorReference options {customInterface; stubBase = "PatternBase";}
 :
	(
      moduleReference<QUALIFIER, Qualifier>
      DOT<FSHARP_DOT, Dot>
    )?
    identifier<REFERENCE_NAME, ReferenceName>	
;

constantPattern options {customInterface;  stubBase = "PatternBase";}
 :
	constantValue{VALUE, Value}
;

rangePattern options { stubBase = "PatternBase";}
 :
	CHARACTER_LITERAL<LOWER_BOUND, LowerBound>
	DOT_DOT<FSHARP_DOTDOT, DotDot>	
	CHARACTER_LITERAL<UPPER_BOUND, UpperBound>	
;

typeTestPattern options {stubBase = "PatternBase";}
 :
	COLON_QMARK<FSHARP_COLONQUEST, Colonquest>
	typeExpression<TYPE_EXPRESSION, TypeExpression>
;

//  A.4.1 Grammar part for type definitions

typeDefinition options {customInterface; }
 :
	TYPE_KEYWORD<FSHARP_TYPE, TypeKeyword>
	LIST typeDeclaration<TYPE_DECLARATION, TypeDeclarations> SEP AND_KEYWORD<FSHARP_AND, AndKeyword>		
;

errorhandling typeDeclaration options {customInterface; 
	stubBase = "JetBrains.ReSharper.Psi.FSharp.Impl.InferenceCacheSupport.InferenceTypeBase";}
  extras {
	get { methodName="TypeParameters" path=<typeDeclaration:
TYPE_PARAMETERS/typeParameterList:
PARAMETER_DECLARATION> };
  }
 :
	// (attribute<ATTRIBUTE, Attributes)*
	typeParameterList<TYPE_PARAMETERS,TypeParameterList>?
	identifier<TYPE_NAME, TypeName>
	EQUALS<FSHARP_EQ, Eq>
	typeInformation<TYPE_INFORMATION, TypeInformation>?
;

typeParameterList
 :	 
	LPAREN<FSHARP_LPARENTH, LParenth>
	LIST typeParameterDeclaration<PARAMETER_DECLARATION, ParameterDeclarations> SEP COMMA<FSHARP_COMMA, Comma>
	RPAREN<FSHARP_RPARENTH, RParenth>
 |
	typeParameterDeclaration<PARAMETER_DECLARATION, ParameterDeclarations>
;
 
errorhandling typeParameterDeclaration options {customInterface;
  stubBase = "JetBrains.ReSharper.Psi.FSharp.Impl.InferenceCacheSupport.InferenceTypeBase";
}				
 :
	(
		QUOTE<FSHARP_QUOT, Apostrophe>
	  |
		DOLLAR<FSHARP_DOLLAR, Dollar>
	)
	identifier<PARAMETER, ParameterName>
;

errorhandling interface typeInformation
 :
	typeRepresentation 
 |
	typeExpression
 |
	typeRefOrConstructorDecl
;

interface typeRepresentation
 :
	  algebraicTypeRepresentation  
	|
	  recordTypeRepresentation 
;

algebraicTypeRepresentation
 :
	BAR<FSHARP_OR, Or>?
	LIST constructorDeclaration<CONSTRUCTOR, Constructors> SEP BAR<FSHARP_OR, Or>
;

recordTypeRepresentation
 extras {
	get { methodName="FieldDeclarations" path=<recordTypeRepresentation:
FIELD_DECLARATIONS/fieldDeclarationList:
FIELD_DECLARATION> };
  }
 :
	LBRACE<FSHARP_LBRACE, LBrace>
	fieldDeclarationList<FIELD_DECLARATIONS, FieldDeclarationList>
	RBRACE<FSHARP_RBRACE, RBrace>
;

errorhandling constructorDeclaration options {customInterface; 
  stubBase = "JetBrains.ReSharper.Psi.FSharp.Impl.InferenceCacheSupport.InferenceTypeBase";}
  extras {
	get { methodName="TypeDeclaration" path=<algebraicTypeRepresentation:
CONSTRUCTOR/typeDeclaration:
TYPE_INFORMATION> };
  }
 :
	identifier<CONSTRUCTOR_NAME, ConstructorName> 	
	(
		OF_KEYWORD<KEYWORD_OF, OfKeyword>
		typeExpression<TYPE_EXPRESSION, TypeExpression>
	)?
;

//dynamic node: declaration of Constructor if not resolved, typeReference else...
//todo: Used in F#Parser in TypeInformation parsing
typeRefOrConstructorDecl options {customInterface;}
 extras {
	get { methodName="TypeDeclaration" path=<typeDeclaration:
TYPE_INFORMATION> };
  }
 :
	identifier<NAME, Name>
;

//Warning! Overriding in FSharpParser!!!...	
fieldDeclarationList
 :
	LIST fieldDeclaration <FIELD_DECLARATION, FieldDeclarations> 
	     SEP SEMICOLON<FSHARP_SEMICOLON, Semicolon>	
;

errorhandling fieldDeclaration options { customInterface; }
 :
	MUTABLE_KEYWORD<KEYWORD_MUTABLE, MutableKeyword>?
	identifier<FIELD, FieldName>
	COLON<FSHARP_COLON, Colon>
	typeSchemeExpression<TYPE_SCHEME, typeSchemeExpression>	
;

//Warning! Overriding in FSharpParser!!!...	
errorhandling interface typeSchemeExpression
 :
	  typeExpression<TYPE_EXPRESSION, TypeExpression>
	|
	  !(#param: typeParameterDeclaration)	  	  
	  forAllTypeExpression<TYPE_EXPRESSION, TypeExpression>[param]
;
  
forAllTypeExpression [typeParameterDeclaration param]
:
	//QUOTE<FSHARP_QUOT, Apostrophe>
	//identifier<PARAMETER, ParameterName>
	&param<PARAMETER, Parameter>
	DOT<FSHARP_DOT, Dot>
	typeExpression<PARAMETERIZED_TYPE_EXPRESSION, ParameterizedTypeExpression>
;

//  A.4.2 Grammar part for type expressions

interface parameterizedTypeReference options {customInterface;}
 :
	oneParameterTypeReference
  |
	multiParameterTypeReference
  |
	withoutParameterTypeReference	  
;

errorhandling interface typeExpression options {
   multilevel: (
	  "Fun" righta functionType
	;
	  "Tuple" tupleType
	;
	  "Appl" oneParameterTypeReference, arrayType, lazyType
   );
   customInterface;
   }
 :
	functionType		
 |
 	tupleType			
 |
	arrayType	 
 |
	lazyType	
 |		
	typeParameterReference
 | 
	underlineType
 |
	parenthesizedType
 |
	oneParameterTypeReference
 |
	multiParameterTypeReference
 |
	withoutParameterTypeReference	
; 
 
functionType options { customInterface; stubBase = "TypeExpressionBase";}
 :
	typeExpression<DOMAIN, Domain>
	RARROW<FSHARP_RARROW, RArrow>
	typeExpression<RANGE, Range>
;

tupleType options { customInterface; stubBase = "TypeExpressionBase";}
 :
	typeExpression<TYPE_EXPRESSION, TypeExpression>
	(
		STAR<FSHARP_ASTERISK, Asterisk>
		typeExpression<TYPE_EXPRESSION, TypeExpression>
	)+
;

arrayType options { customInterface; stubBase = "TypeExpressionBase";  }
 :
	typeExpression<ARRAY_NAME, ArrayName>
	LBRACK<FSHARP_LBRACKET, LBracket>
	(COMMA<FSHARP_COMMA, Comma>)*
	RBRACK<FSHARP_RBRACKET, RBracket>
;

lazyType options { customInterface; stubBase = "TypeExpressionBase"; }
 :
	typeExpression<TYPE_EXPRESSION, TypeExpression>
	LAZY_KEYWORD<LAZY_KEYWORD, LazyKeyword>
;


oneParameterTypeReference options {customInterface; customInterface;}
 :
	typeExpression<PARAMETER, Parameter>
	typeReference<TYPE_REFERENCE, TypeReference>		
;

typeParameterReference options {customInterface; stubBase = "TypeExpressionBase";  }
 :
	(
		QUOTE<FSHARP_QUOT, Apostrophe>
	  |
		DOLLAR<FSHARP_DOLLAR, Dollar>
	)
	identifier<PARAMETER, ParameterName> 
;

parenthesizedType options {customInterface; stubBase = "TypeExpressionBase"; }
 :
	!(#lparenth:
LPAREN)
	!(#expression:
typeExpression)
	parenthesizedTypeAux[lparenth, expression]
;

private parenthesizedTypeAux[LPAREN lparenth, typeExpression expression] options {}
 :
	&lparenth<FSHARP_LPARENTH, LParenth>
	&expression<TYPE_EXPRESSION, TypeExpression>
	RPAREN<FSHARP_RPARENTH, RParenth>		
;

multiParameterTypeReference options {customInterface; }
 :
	!(#lparenth:
LPAREN)
	!(#expression:
typeExpression)
	multiParameterTypeReferenceAux[lparenth, expression]
;

private multiParameterTypeReferenceAux[LPAREN lparenth, typeExpression expression] options {}
 :
	&lparenth<FSHARP_LPARENTH, LParenth>
	&expression<PARAMETER, Parameters>
	COMMA<FSHARP_COMMA, Comma>
	LIST typeExpression<PARAMETER, Parameters> SEP COMMA<FSHARP_COMMA, Comma>
	RPAREN<FSHARP_RPARENTH, RParenth>
	typeReference<TYPE_REFERENCE, TypeReference>	
;

withoutParameterTypeReference options {customInterface; }
 :
	typeReference<TYPE_REFERENCE, TypeReference>
;

//typeRefOrConstrDecl is typeReference also!...
typeReference options{customInterface; stubBase = "TypeExpressionBase";  }
 :
	(
      moduleReference<QUALIFIER, Qualifier>
      DOT<FSHARP_DOT, Dot>
    )?
    identifier<REFERENCE_NAME, ReferenceName>	
;

underlineType options {customInterface; stubBase = "TypeExpressionBase";  }
 :
	UNDERSCORE<FSHARP_UNDERLINE, Underline>
;

// Operation Interfaces

interface binaryExpression
 :
	binaryAddExpression
 |
	binaryMultExpression
 |
	binaryPowerExpression
 |
	comparisonExpression
 |
	andExpression
 |
	orExpression	
 |
 	listConcatenateExpression
 |
	stringConcatenateExpression
 |
	assignExpression
 |
	assignFieldExpression
 |		
	listConstructorExpression	
 |
	infixOperatorExpression	
// |
//	parenthesizedFieldValueExpression
// |
//	bracketedFieldValueExpression	
;

interface unaryExpression
 :
	unaryMinusExpression
  |	
	prefixOperatorExpression
;

interface operatorExpression options {customInterface; }
 :
	unaryExpression
 |
	binaryExpression
;

/// A.5 Expressions			

errorhandling interface expression options {   
   multilevel: (
	 "Seq" righta expressionSequence	 
	;	
	 "Assign" righta assignExpression, assignFieldExpression
	;
	 "Tuple" tupleExpression
	;	
	 "Or" orExpression
	;
	 "And" andExpression
	;
	 "Compare" comparisonExpression, infixOperatorExpression
	;
	 "Concat" righta listConcatenateExpression, stringConcatenateExpression
	;
	 "List" righta listConstructorExpression
	;
	 "Add" binaryAddExpression
	;
	 "Mult" binaryMultExpression	
	;
	 "Power" binaryPowerExpression
	;
	 "UnaryMinus" unaryMinusExpression   //Warning! Overriding in FSharpParser!!!...	 
	;
	 "Appl" applicationExpression		 //Warning! Overriding in FSharpParser!!!...
	;
	 "FieldValue" parenthesizedFieldValueExpression, bracketedFieldValueExpression, memberAccessExpression  
										 //Warning! Overriding in FSharpParser!!!...
	;
	 "Unary" prefixOperatorExpression			 //Warning! Overriding in FSharpParser!!!...
  );
   customInterface;
 }  
 :	
	tupleExpression	
 |
	expressionSequence 
 |
	applicationExpression
 |  
	valueReferenceExpression
 |
 	localDeclarationsInExpression
 |
	typedExpression 
 |
	constantExpression 
 |
	parenthesizedExpression
 |	
	bracketedExpression
 |
	arrayExpression
 |
	recordExpression
 |
	withRecordExpression
 |
	creationWithOverridingMethodsExpression
 |	

// IOperatorExpression Section
	unaryMinusExpression
  |	
	prefixOperatorExpression
 |
	binaryAddExpression
 |
	binaryMultExpression
 |
	binaryPowerExpression
 |
	comparisonExpression
 |
	andExpression
 |
	orExpression	
 |
 	listConcatenateExpression
 |
	stringConcatenateExpression
 |
	assignExpression
 |
	assignFieldExpression
 |		
	listConstructorExpression	
 |
	infixOperatorExpression	
// End of Section
 
 |
 
// Dot Operators Section
	memberAccessExpression
 |
	parenthesizedFieldValueExpression
 |
	bracketedFieldValueExpression		
//End of Section
 
 |
	expressionBlock
 |
	ifStatementExpression
 |
	whileStatementExpression
 |
	forStatementExpression
 |
	funExpression
 |
	functionExpression
 |
	tryWithExpression 
 |
	tryFinallyExpression
 |
	matchExpression
 |	
	creationExpression
 |
	assertExpression
 |
	lazyExpression	
 |
	upcastExpression
 |
	downcastExpression
 |
	upcastExpressionToType
 |
	downcastExpressionToType
 |
	typeTestExpression

// |
//    parameterizedExpression    
 ;
 
errorhandling tupleExpression options { stubBase = "FSharpExpressionBase";}
 :
	expression<EXPRESSION, Expression>
	(
	  COMMA<FSHARP_COMMA, Comma>	
	  expression<EXPRESSION, Expression>
	)+
 ;
  
expressionSequence options { stubBase = "FSharpExpressionBase";}
 :
	expression<EXPRESSION1, Expression1>
	SEMICOLON<FSHARP_SEMICOLON, Semicolon>	
	expression<EXPRESSION2, Expression2>	
;


applicationExpression options {stubBase = "FSharpExpressionBase";}
 :
	expression<EXPRESSION, Expression>
	expression<OPERAND, Operand>
;

valueReferenceExpression options {customInterface; stubBase = "ReferenceExpressionBase";}
 :
    (
      moduleReference<QUALIFIER, Qualifier>
      DOT<FSHARP_DOT, Dot>
    )?
    valueName<REFERENCE_NAME, ReferenceName>	
;

errorhandling interface valueReferenceExpressionOld
 :
	qualifiedValueReference	
  |
	qualifiedIdReference	
;

qualifiedValueReference options {customInterface; stubBase = "FSharpExpressionBase";}
 :
	qualifiedValueName<REFERENCE_VALUE, ReferenceValue>
;

qualifiedIdReference options {stubBase = "FSharpExpressionBase";}
 :
	LIST idReference<REFERENCES, References> SEP DOT<FSHARP_DOT, Dot>
;

idReference options {customInterface;  
	stubBase = "JetBrains.ReSharper.Psi.FSharp.Impl.InferenceCacheSupport.InferenceTypeBase";}
 :
	identifier<NAME, Identifier> 
;

// errorhandling ???
/*errorhandling valueReferenceExpressionOld options { customInterface; stubBase = "FSharpExpressionBase";}
 :
	qualifiedValueName<REFERENCE_VALUE, ReferenceValue>
;
*/

localDeclarationsInExpression options { customInterface; stubBase = "FSharpExpressionBase"; }
 :
	LET_KEYWORD<FSHARP_LET, LetKeyword>
	REC_KEYWORD<FSHARP_REC, RecKeyword>?
	LIST binding<BINDING, Bindings> SEP AND_KEYWORD<FSHARP_AND, AndKeyword>
	IN_KEYWORD<FSHARP_IN, InKeyword>
	expression<EXPRESSION, Expression>
;

typedExpression options {stubBase = "FSharpExpressionBase";}
 :
    !(#lparenth: LPAREN)
	!(#expression: expression)
	typedExpressionAux[lparenth, expression]
 ;

//errorhandling ???
private typedExpressionAux[LPAREN lparenth, expression expression] options {}
 :
	&lparenth<FSHARP_LPARENTH, LParenth>
	&expression<EXPRESSION, Expression>
	COLON<FSHARP_COLON, Colon>
	typeExpression<TYPE_EXPRESSION, TypeExpression>	
	RPAREN<FSHARP_RPARENTH, RParenth>
;

// errorhandling ???
errorhandling constantExpression options { customInterface; stubBase = "FSharpExpressionBase";}
 :
	constantValue{VALUE, Value}
;


parenthesizedExpression options { stubBase = "FSharpExpressionBase"; }
 :
	!(#lparenth: LPAREN)
	!(#expression: expression)
	parenthesizedExpressionAux[lparenth, expression]
 ;

// errorhandling???
private parenthesizedExpressionAux[LPAREN lparenth, expression expression] options {}
 :
	&lparenth<FSHARP_LPARENTH, LParenth>
	&expression<EXPRESSION, Expression>
	RPAREN<FSHARP_RPARENTH, RParenth>
;

bracketedExpression options {stubBase = "FSharpExpressionBase";}
 :
	LBRACK<FSAHRP_LBRACKET, LBracket>
	expression<EXPRESSION, Expression>
	RBRACK<FSAHRP_LBRACKET, RBracket>
 ;

arrayExpression options {stubBase = "FSharpExpressionBase";}
 :
	LBRACK_BAR<FSAHRP_LBRACKET, LBracket>									
	expression<EXPRESSION, Expression>
	//LIST expression<EXPRESSION, Expressions> SEP SEMICOLON<FSHARP_SEMICOLON, Semicolon>
	BAR_RBRACK<FSAHRP_RBRACKET, RBracket>
 ;
 
recordExpression options {stubBase = "FSharpExpressionBase";}				
extras {
	get { methodName="FieldAssignments" path=<recordExpression:
FIELD_ASSIGNMENTS/fieldAssignmentList:
FIELD_ASSIGNMENT> };
  }
 :
	LBRACE<FSAHRP_LBRACE, LBrace>	
	fieldAssignmentList<FIELD_ASSIGNMENTS, fieldAssignmentList>
	RBRACE<FSAHRP_RBRACE, RBrace>
 ;
 
 //Warning! Overriding in FSharpParser!!!...
fieldAssignmentList
  :
	LIST fieldAssignment<FIELD_ASSIGNMENT, FieldAssignments> 
	     SEP SEMICOLON<FSHARP_SEMICOLON, Semicolon>	
 ;
 
 //Warning! Overriding in FSharpParser!!!...
fieldAssignment
  :
	fieldReference<FIELD, FieldName>
	EQUALS<FSAHRP_EQ, Eq>
	expression<FIELD_VALUE, FieldValue>		
 ; 
 
withRecordExpression options { stubBase = "FSharpExpressionBase";}				
extras {
	get { methodName="FieldAssignments" path=<withRecordExpression:
FIELD_ASSIGNMENTS/fieldAssignmentList:
FIELD_ASSIGNMENT> };
  }
 :
	LBRACE<FSAHRP_LBRACE, LBrace>
	expression<EXPRESSION, Expression>
	WITH_KEYWORD<WITH_KEYWORD, WithKeyword>
	fieldAssignmentList<FIELD_ASSIGNMENTS, fieldAssignmentList>
	RBRACE<FSAHRP_RBRACE, RBrace>	
 ; 
 
creationWithOverridingMethodsExpression options {stubBase = "FSharpExpressionBase";}
 :	
	!(#lbrace: LBRACE)
	creationWithOverridingMethodsExpressionAux[lbrace]
; 

private creationWithOverridingMethodsExpressionAux[LBRACE lbrace] options {}
 :
	&lbrace<FSAHRP_LBRACE, LBrace>
	creationExpression<CREATION_EXPRESSION, CreationExpression>
	WITH_KEYWORD<WITH_KEYWORD, WithKeyword>
	LIST bindingScheme<BINDING_SCHEME, BindingSchemes> SEP AND_KEYWORD<AND_KEYWORD, AndKeyword>
	RBRACE<FSAHRP_RBRACE, RBrace>		
;

// **********  Unary Operators Section  **********
unaryMinusExpression options { stubBase = "OperatorExpressionBase";}
 :
	(
		MINUS<OPERATION_SIGN, OperationSign>
		|
		MINUS_DOT<OPERATION_SIGN, OperationSign>
	)
	expression<OPERAND, Operand>
;

prefixOperatorExpression options { stubBase = "OperatorExpressionBase"; }
 :
	prefixSymbol{OPERATION_SIGN, OperationSign}
	expression<OPERAND, Operand>
;
// **********  Unary Operators Section End  **********

// **********  Binary Operators Section  **********
binaryAddExpression options { stubBase = "OperatorExpressionBase";}
 :
	expression<LEFT_OPERAND, LeftOperand>
	(
		PLUS<OPERATION_SIGN, OperationSign>
		|
		MINUS<OPERATION_SIGN, OperationSign>
	)
	expression<RIGHT_OPERAND, RightOperand>
;

binaryMultExpression options { stubBase = "OperatorExpressionBase";}
 :
	expression<LEFT_OPERAND, LeftOperand>
	(
		STAR<OPERATION_SIGN, OperationSign>
		|
		PERCENT<OPERATION_SIGN, OperationSign>
		|
		DIV<OPERATION_SIGN, OperationSign>
	)
	expression<RIGHT_OPERAND, RightOperand>
;

binaryPowerExpression options { stubBase = "OperatorExpressionBase";}
 :
	expression<LEFT_OPERAND, LeftOperand>
	STAR_STAR<OPERATION_SIGN, OperationSign>
	expression<RIGHT_OPERAND, RightOperand>
;

comparisonExpression options { stubBase = "OperatorExpressionBase";}
 :
	expression<LEFT_OPERAND, LeftOperand>
	(
		EQUALS<OPERATION_SIGN, OperationSign>
		|
		LESS<OPERATION_SIGN, OperationSign>
		|
		GREATER<OPERATION_SIGN, OperationSign>		
		|
		LESS_GREATER<OPERATION_SIGN, OperationSign>
	)
	expression<RIGHT_OPERAND, RightOperand>
;

andExpression options { stubBase = "OperatorExpressionBase";}
 :
	expression<LEFT_OPERAND, LeftOperand>
	(
	  AMP_AMP<OPERATION_SIGN, OperationSign>
	)
	expression<RIGHT_OPERAND, RightOperand>
;

orExpression options { stubBase = "OperatorExpressionBase";}
 :
	expression<LEFT_OPERAND, LeftOperand>
	(
	  BAR_BAR<OPERATION_SIGN, OperationSign>
	)
	expression<RIGHT_OPERAND, RightOperand>
;

listConcatenateExpression options { stubBase = "OperatorExpressionBase";}
 :
	expression<LEFT_OPERAND, LeftOperand>
	AT<FSHARP_AT, OperationSign>		
	expression<RIGHT_OPERAND, RightOperand>
;

stringConcatenateExpression options { stubBase = "OperatorExpressionBase";}
 :
	expression<LEFT_OPERAND, LeftOperand>
	CARET<OPERATION_SIGN, OperationSign>		
	expression<RIGHT_OPERAND, RightOperand>
;

assignExpression options { stubBase = "OperatorExpressionBase"; }
 :
	expression<LEFT_OPERAND, LeftOperand>
	COLON_EQUALS<OPERATION_SIGN, OperationSign>
	expression<RIGHT_OPERAND, RightOperand>
;

assignFieldExpression options { stubBase = "OperatorExpressionBase"; }
 :
	expression<LEFT_OPERAND, LeftOperand>
	LARROW<OPERATION_SIGN, OperationSign>
	expression<RIGHT_OPERAND, RightOperand>
;

listConstructorExpression options { stubBase = "OperatorExpressionBase"; }
 :
	expression<LEFT_OPERAND, LeftOperand>
	COLON_COLON<OPERATION_SIGN, OperationSign>
	expression<RIGHT_OPERAND, RightOperand>	
;

infixOperatorExpression options { stubBase = "OperatorExpressionBase"; }
:
	expression<LEFT_OPERAND, LeftOperand>
	(
		BAR<OPERATION_SIGN, OperationSign>
		|
		AMP<OPERATION_SIGN, OperationSign>	
		|
		DOLLAR<OPERATION_SIGN, OperationSign>	
	)
	expression<RIGHT_OPERAND, RightOperand>
;
// **********  Binary Operators Section End **********

// **********  Dot Operators Section  **********
memberAccessExpression  options { customInterface; stubBase = "ReferenceExpressionBase";}
 :
	expression<QUALIFIER, Qualifier>
	DOT<FSHARP_DOT, Dot>
	valueReferenceExpression<REFERENCE_NAME, ReferenceName>
;

parenthesizedFieldValueExpression options {stubBase = "OperatorExpressionBase";}
 :
	expression<LEFT_OPERAND, LeftOperand>
	DOT<FSHARP_DOT, Dot>
	LPAREN<FSHARP_LPARENTH, LParenth>
	expression<RIGHT_OPERAND, RightOperand>
	RPAREN<FSHARP_RPARENTH, RParenth>
;

bracketedFieldValueExpression options {stubBase = "OperatorExpressionBase";}
 :
	expression<LEFT_OPERAND, LeftOperand>
	DOT<FSHARP_DOT, Dot>
	LBRACK<FSHARP_LBRACKET, LBracket>
	expression<RIGHT_OPERAND, RightOperand>
	RBRACK<FSHARP_RBRACKET, RBracket>		
;
// **********  Dot Operators Section End **********

expressionBlock options {stubBase = "FSharpExpressionBase";}
 :
	BEGIN_KEYWORD<FSHARP_BEGIN, BeginKeyword>
	expression<BLOCK, Block> 
	END_KEYWORD<FSHARP_END, EndKeyword>   
;

ifStatementExpression options {stubBase = "FSharpExpressionBase";}
 :
	IF_KEYWORD<FSHARP_IF, IfKeyword>
	expression<CONDITION, Condition>
	THEN_KEYWORD<FSHARP_THEN, ThenKeyword>   
	expression<THEN_STATEMENT, ThenStatement>
	(
		ELSE_KEYWORD<FSHARP_ELSE, ElseKeyword>
		expression<ELSE_STATEMENT, ElseStatement>   
	)?
;
 
whileStatementExpression options {stubBase = "FSharpExpressionBase";}
 :
	WHILE_KEYWORD<FSHARP_WHILE, WhileKeyword>
	expression<CONDITION, Condition>
	DO_KEYWORD<FSHARP_DO, DoKeyword>   
	expression<BODY, Body>
	DONE_KEYWORD<FSHARP_DONE, DoneKeyword>   
;

forStatementExpression options {customInterface; stubBase = "FSharpExpressionBase";}
 :
	FOR_KEYWORD<FSHARP_FOR, ForKeyword>
	identifier<VARIABLE, LoopVariable>
	EQUALS<FSHARP_EQ, Eq>
	expression<LOWER_BOUND, LowerBound>
	(
		TO_KEYWORD<TO_KEYWORD, ToKeyword>
		|
		DOWNTO_KEYWORD<DOWNTO_KEYWORD, DowntoKeyword>
	)
	expression<UPPER_BOUND, UpperBound>
	DO_KEYWORD<FSHARP_DO, DoKeyword>   
	expression<BODY, Body>
	DONE_KEYWORD<FSHARP_DONE, DoneKeyword>   	
;

funExpression options {stubBase = "FSharpExpressionBase";}
extras {
  get { methodName="Condition" path=<funExpression:
FUNCTION_DEFINITION/multipleMatching:
CONDITION> };
  get { methodName="Parameters" path=<funExpression:
FUNCTION_DEFINITION/multipleMatching:
PARAMETER> };
  get { methodName="Target" path=<funExpression:
FUNCTION_DEFINITION/multipleMatching:
TARGET> };
}
 :
	FUN_KEYWORD<FSHARP_FUN, FunKeyword>
	multipleMatching<FUNCTION_DEFINITION, FunctionDefinition>
;

multipleMatching options {customInterface;}
 :
	(pattern<PARAMETER, Parameters>)+
	multipleMatchingAux
;

private multipleMatchingAux
 :
   (
 		WHEN_KEYWORD<WHEN_KEYWORD, WhenKeyword>
		expression<CONDITION, Condition>
	)?
	RARROW<FSHARP_RARROW, RArrow>
	expression<TARGET, Target>		
;

functionExpression  options { stubBase = "FSharpExpressionBase"; }
 :
	FUNCTION_KEYWORD<FUNCTION_KEYWORD, FunctionKeyword>
	patternMatching<FUNCTION_DEFINITION, FunctionDefinition>
;

tryWithExpression options { stubBase = "FSharpExpressionBase";}
 :
	!(#tryKW: TRY_KEYWORD)
	!(#expression: expression)
	tryWithExpressionAux[tryKW, expression]
;

private tryWithExpressionAux[TRY_KEYWORD tryKW, expression expression] options {}
 :
	&tryKW<FSHARP_TRY, TryKeyword>
	&expression<EXPRESSION, Expression>
	WITH_KEYWORD<FSHARP_WITH, WithKeyword>
	patternMatching<PATTERN_MATCHING, PatternMatching>
;

tryFinallyExpression options {stubBase = "FSharpExpressionBase";}
 :
	!(#tryKW: TRY_KEYWORD)
	!(#expression: expression)
	tryFinallyExpressionAux[tryKW, expression]
;

private tryFinallyExpressionAux[TRY_KEYWORD tryKW, expression expression] options {}
 :
	&tryKW<FSHARP_TRY, TryKeyword>
	&expression<EXPRESSION, Expression>
	FINALLY_KEYWORD<FSHARP_FINALLY, FinallyKeyword>
	expression<FINALLY_EXPRESSION, FinallyExpression>
;

matchExpression options {stubBase = "FSharpExpressionBase";}
 :
	MATCH_KEYWORD<FSHARP_MATCH, MatchKeyword>
	expression<EXPRESSION, Expression>
	WITH_KEYWORD<FSHARP_WITH, WithKeyword>
	patternMatching<PATTERN_MATCHING, PatternMatching>
;

patternMatching
 :
	BAR<FSHARP_OR, Or>?	
	LIST matchClause<MATCH_CLAUSE, Clauses> SEP BAR<FSHARP_OR, Or>
;

errorhandling matchClause options {customInterface;}
 :
	pattern<PATTERN, Pattern>
	  (
	  	 WHEN_KEYWORD<WHEN_KEYWORD, WhenKeyword>
		 expression<CONDITION, Condition>
	  )?
	RARROW<FSHARP_RARROW, RArrow>
	expression<TARGET, Target>
;

//Warning! Overriding in FSharpParser!!!...
creationExpression options {stubBase = "FSharpExpressionBase";}
 :
	NEW_KEYWORD<NEW_KEYWORD, NewKeyword>
	typeExpression<TYPE, CreatedType>
	(
		LPAREN<FSHARP_LPARENTH, LParenth>
		tupleExpression<ARGUMENT_LIST, ArgumentList>
		RPAREN<FSHARP_RPARENTH, RParenth>	
	)?
;

assertExpression options { stubBase = "FSharpExpressionBase"; }
 :
	ASSERT_KEYWORD<ASSERT_KEYWORD, AssertKeyword>
	expression<EXPRESSION, Expression>
;

lazyExpression options { stubBase = "FSharpExpressionBase"; }
 :
	LAZY_KEYWORD<LAZY_KEYWORD, LazyKeyword>
	expression<EXPRESSION, Expression>
;

upcastExpression options { stubBase = "FSharpExpressionBase"; }
 :
	UPCAST_KEYWORD<UPCAST_KEYWORD, UpcastKeyword>
	expression<EXPRESSION, Expression>
;

downcastExpression options { stubBase = "FSharpExpressionBase"; }
 :
	DOWNCAST_KEYWORD<DOWNCAST_KEYWORD, DowncastKeyword>
	expression<EXPRESSION, Expression>
;

upcastExpressionToType options { stubBase = "FSharpExpressionBase"; }
 :
	!(#lparenth: LPAREN)
	!(#expression: expression)
	upcastExpressionToTypeAux[lparenth, expression]
;

private upcastExpressionToTypeAux[LPAREN lparenth, expression expression] options {}
 :
	&lparenth<FSHARP_LPARENTH, LParenth>
	&expression<EXPRESSION, Expression>
	COLON_GREATER<FSHARP_COLONGT, ColonGT>
	typeExpression<TYPE, Type>
	RPAREN<FSHARP_RPARENTH, RParenth>	
;

downcastExpressionToType options { stubBase = "FSharpExpressionBase"; }
 :
	!(#lparenth: LPAREN)
	!(#expression: expression)
	downcastExpressionToTypeAux[lparenth, expression]
;

private downcastExpressionToTypeAux[LPAREN lparenth, expression expression] options {}
 :
	&lparenth<FSHARP_LPARENTH, LParenth>
	&expression<EXPRESSION, Expression>
	COLON_QMARK_GREATER<FSHARP_COLONQUESTGT, ColonQuestGT>
	typeExpression<TYPE, Type>
	RPAREN<FSHARP_RPARENTH, RParenth>	
;

typeTestExpression options { stubBase = "FSharpExpressionBase"; }
 :
	!(#lparenth: LPAREN)
	!(#expression: expression)
	typeTestExpressionAux[lparenth, expression]
;

private typeTestExpressionAux[LPAREN lparenth, expression expression] options {}
 :
	&lparenth<FSHARP_LPARENTH, LParenth>
	&expression<EXPRESSION, Expression>
	COLON_QMARK<FSHARP_COLONQUEST, ColonQuest>
	typeExpression<TYPE, Type>
	RPAREN<FSHARP_RPARENTH, RParenth>	
;